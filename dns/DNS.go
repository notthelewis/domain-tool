package dns

import (
	qt "domain-tool/dns/QueryType"
	"encoding/binary"
	"fmt"
	"math/rand/v2"
)

// DNSMessage is the fundamental interchange format between client and server.
type DNSMessage struct {
	Flags                 DNSFlags // Message specific flags set dependent on use case
	Questions             []DNSQuestion
	Answers               []ResourceRecord
	Authority             []ResourceRecord
	AdditionalInformation []ResourceRecord
}

// Encode a DNS message into a byte slice into the expected format.
func (dnsMsg *DNSMessage) Encode() []byte {
	header := make([]byte, 0, 12)

	qLen := len(dnsMsg.Questions)
	anLen := len(dnsMsg.Answers)
	auLen := len(dnsMsg.Authority)
	adLen := len(dnsMsg.AdditionalInformation)

    // Almost completely arbitrary in terms of pre-alloc, though it's better than the Go standard
    // TODO: Prove the above is true :')
	bodyLen := (qLen + anLen + auLen + adLen) * 64
	body := make([]byte, 0, bodyLen)

	// Write Identification
	header = binary.BigEndian.AppendUint16(header, uint16(rand.UintN(0xFFFF)))

	// Write Flags
	header = binary.BigEndian.AppendUint16(header, dnsMsg.Flags.Encode())

	// Write variable int fields
	header = binary.BigEndian.AppendUint16(header, uint16(qLen))
	header = binary.BigEndian.AppendUint16(header, uint16(anLen))
	header = binary.BigEndian.AppendUint16(header, uint16(auLen))
	header = binary.BigEndian.AppendUint16(header, uint16(adLen))

    // Write body 
	for _, r := range dnsMsg.Questions {
        body = append(body, r.Encode()...)
	}

	return header
}

// DNSFlags are the flags which indicate properties about the DNSMessage.
type DNSFlags struct {
	QR     bool  // 0 == query, 1 == response
	OpCode uint8 // 4bit field. 0 == standard query, 1 == inverse query, 2 == server status request
	AA     bool  // Name server is authorative
	TC     bool  // Reply exceeded 512 bytes
	RD     bool  // Recursion desired
	RA     bool  // Recursion available
	Rcode  uint8 // 4bit field. 0 == no error, 3 == name error
}

// Encode will take a DNSFlags and encode it as a single uint16
func (F *DNSFlags) Encode() uint16 {
    return uint16((b2i(F.QR)<<7|int(F.OpCode)<<3|b2i(F.AA)<<2|b2i(F.RD))<<8 | b2i(F.RA)<<7 | 0x00<<4 | int(F.Rcode))
}

func (F DNSFlags) String() string {
	return fmt.Sprintf("{QR:%t, OpCode:%v, AA:%t,TC:%t, RD:%t, RA:%t, Rcode:%v}", F.QR, F.OpCode, F.AA, F.TC, F.RD, F.RA, F.Rcode)
}

// DNSQuestion is an individual request generated by the client for a specific piece of data
type DNSQuestion struct {
	QueryName  []Label
	QueryType  qt.QueryType
	QueryClass uint16
}

func (Q DNSQuestion) Encode() []byte {
	// This is imperfect, as a reslice could happen if every label is max length...
	// though that reslice is such a rare occurance that this is a viable trade off.
	// another downside is that this will probably overalloc, though the numbers are so small it doesn't actually matter
	buf := make([]byte, 0, 63*len(Q.QueryName)+4)
	for _, l := range Q.QueryName {
		buf = append(buf, l.Encode()...)
	}
	buf = append(buf, 0)
	buf = binary.BigEndian.AppendUint16(buf, Q.QueryType.Get())
	buf = binary.BigEndian.AppendUint16(buf, Q.QueryClass)

    return buf
}

// Label is part of a domain, i.e. in `test.com`, `test` and `com` are labels
type Label struct {
	Name []byte
}

// Encode will take in a label and encode it into a byte slice in the format required by DNS protocol.
// The format is a length-prepended, variable length byte array.
// I.e. `test.com` will be encoded as two separate labels: `4test`, `3com`
func (L *Label) Encode() []byte {
	if len(L.Name) > 63 {
		panic("Max length of 63 for label exceeded")
	}

	buf := make([]byte, 0, len(L.Name)+1)
	buf = append(buf, uint8(len(L.Name)))
	buf = append(buf, L.Name...)

	return buf
}

// ResourceRecord is used for server responses to questions
type ResourceRecord struct {
	DomainName         []Label
	Type               qt.QueryType
	Class              uint16
	TTL                uint16
	ResourceDataLength uint16
	ResourceData       []byte
}

func (R *ResourceRecord) Encode() []byte {
	buf := make([]byte, 0)

	for _, dn := range R.DomainName {
		buf = append(buf, dn.Encode()...)
	}

	// Label terminate
	buf = append(buf, 0x00)

	buf = binary.BigEndian.AppendUint16(buf, R.Type.Get())
	buf = binary.BigEndian.AppendUint16(buf, R.Class)
	buf = binary.BigEndian.AppendUint16(buf, R.TTL)
	buf = binary.BigEndian.AppendUint16(buf, R.ResourceDataLength)

	buf = append(buf, R.ResourceData...)

	return buf
}

// b2i converts a bool to integer
func b2i(b bool) int {
	if b {
		return 1
	}

	return 0
}
